"""
Multi-Agent DealFinder System
Orchestrates search, verification, reranking, and synthesis agents
with Redis caching and session management
"""

import os
import datetime
import logging
from typing import Any, List, Dict
from typing_extensions import Literal
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, BaseMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph, END
from langgraph.types import Command
from langgraph.prebuilt import ToolNode
from dotenv import load_dotenv

# Import utilities
from utils import (
    AgentState,
    update_agent_status,
    track_task,
    CacheManager,
    redis_health_check,
    get_session_manager
)
from utils.llm_cache import initialize_llm_cache

# Import agent nodes
from nodes import (
    search_agent,
    verification_agent,
    reranking_agent,
    synthesis_agent
)
from nodes.product_detail_agent import product_detail_agent

# Import search tools
from nodes.search_agent import search_backend_tools

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize LLM cache
initialize_llm_cache()

# Check Redis health
redis_status = redis_health_check()
if redis_status["available"]:
    logger.info(f"âœ… Redis connected: {redis_status['info']}")
else:
    logger.warning(f"âš ï¸  Redis not available: {redis_status.get('error', 'Unknown error')}")


# ========== HELPER FUNCTIONS ==========

def is_product_query(query: str, session_id: str = None) -> bool:
    """
    Detect if query is asking about a specific product from previous results

    Args:
        query: User query
        session_id: Session ID to check for previous results

    Returns:
        True if this is a product-specific query
    """
    if not session_id:
        return False
    
    # Check if session has numbered results
    session_manager = get_session_manager()
    results_data = session_manager.get_all_results_data(session_id)
    
    if not results_data or not results_data.get("numbered_results"):
        return False  # No previous results to reference
    
    query_lower = query.lower()
    
    # Product reference patterns
    product_patterns = [
        r'#\d+',  # #1, #2, etc.
        r'\bproduct\s+\d+',  # product 1, product 2
        r'\bnumber\s+\d+',  # number 1, number 2
        r'\bfirst\s+one\b',  # first one
        r'\bsecond\s+one\b',  # second one
        r'\bthird\s+one\b',  # third one
        r'\btop\s+one\b',  # top one
        r'\bcheapest\b',  # cheapest
        r'\bmost\s+expensive\b',  # most expensive
    ]
    
    import re
    for pattern in product_patterns:
        if re.search(pattern, query_lower):
            return True
    
    # Check for follow-up question patterns
    follow_up_patterns = [
        'tell me about',
        'tell me more',
        'what about',
        'how about',
        'details on',
        'info on',
        'information about',
        'compare',
        'vs',
        'versus',
        'difference between',
    ]
    
    for pattern in follow_up_patterns:
        if pattern in query_lower:
            return True
    
    # Check if query contains product names from results
    for product in results_data.get("numbered_results", {}).values():
        product_name = (product.get("clean_name") or product.get("title", "")).lower()
        # Check if product name (or significant part) is in query
        if product_name and len(product_name) > 5:
            # Split into words and check for partial matches
            name_words = product_name.split()
            significant_words = [w for w in name_words if len(w) > 3]
            if len(significant_words) >= 2:
                # Check if at least 2 significant words match
                matches = sum(1 for word in significant_words if word in query_lower)
                if matches >= 2:
                    return True
    
    return False


# ========== CHAT NODE (Entry Point) ==========

async def chat_node(
    state: AgentState,
    config: RunnableConfig
) -> Command[Literal["tool_node", "search_agent", "product_detail_agent", "synthesis_agent", "__end__"]]:
    """
    Chat Node - Entry point for multi-agent system

    Analyzes user input and routes to appropriate agent or tool execution.
    Handles frontend tool calls, backend tool calls, and product queries.

    Args:
        state: Current agent state
        config: Runtime configuration

    Returns:
        Command to route to next node
    """
    logger.info("ğŸ’¬ Chat Node activated")

    # Initialize session ID if not present
    if not state.get("session_id"):
        import uuid
        session_id = str(uuid.uuid4())[:8]
        state["session_id"] = session_id
        logger.info(f"ğŸ“ New session created: {session_id}")
    else:
        session_id = state["session_id"]
    
    # Get session manager for context handling
    session_manager = get_session_manager()
    
    # Load conversation context for better understanding
    context = session_manager.load_conversation_context(session_id)
    contextual_prompt = session_manager.get_contextual_prompt_addition(session_id)
    
    # Update session activity
    session_manager.update_session_activity(session_id)

    # Get current user message
    current_query = ""
    for msg in reversed(state["messages"]):
        if isinstance(msg, HumanMessage):
            current_query = msg.content
            break

    # Check if this is a product-specific query
    if current_query and is_product_query(current_query, session_id):
        logger.info(f"ğŸ” Product query detected: '{current_query[:50]}...'")
        return Command(
            goto="product_detail_agent",
            update={}
        )

    # 1. Define the model
    model = ChatOpenAI(model="gpt-4o", temperature=0.3)

    # 2. Bind tools to the model
    model_with_tools = model.bind_tools(
        [
            *state.get("tools", []),  # Frontend tools from CopilotKit
            *search_backend_tools,     # Backend search tools
        ],
        parallel_tool_calls=False,
    )

    # 3. Create system prompt
    today = datetime.datetime.today().strftime("%A, %B %d, %Y")

    system_message = SystemMessage(
        content=f"""You are DealFinder AI, an advanced multi-agent shopping assistant powered by specialized AI agents.

**Today's Date:** {today}
**Session ID:** {state.get('session_id', 'N/A')}

**Your Multi-Agent System:**
1. ğŸ” **Search Agent** - Finds deals using Tavily web research (with Redis caching)
2. âœ“ **Verification Agent** - Validates results for quality and accessibility
3. ğŸ”„ **Reranking Agent** - Intelligently orders results by relevance (hybrid AI)
4. ğŸ¨ **Synthesis Agent** - Generates comprehensive answers with numbered references
5. ğŸ” **Product Detail Agent** - Answers follow-up questions about specific products

**Current Pipeline Status:**
{_format_agent_status(state.get('agent_status', {}))}

{contextual_prompt}

**Available Tools:**
- search_for_deals(query, max_price?, category?) - Search for product deals
- extract_product_details(url) - Get detailed product information
- crawl_store_catalog(store_url, category?) - Explore store catalogs
- compare_prices(product_name) - Compare prices across platforms

**Frontend Actions** (for UI updates):
- setThemeColor - Change UI theme
- addDeal - Add deal to UI
- show_deal_card - Display deal card
- addPriceComparison - Show price comparison
- addProverb - Add shopping wisdom

**Your Mission:**
- Help users find the best deals with multi-agent intelligence
- Present search results with numbers (#1, #2, #3...) for easy reference
- Enable follow-up questions like "Tell me more about #2" or "Compare #1 and #3"
- Use conversation context to understand references like "cheaper", "similar", "that product"
- Use tools to search, then let the pipeline handle verification and ranking
- Focus on major retailers: Amazon, eBay, Walmart, Target, Best Buy, Costco
- Provide clear, actionable recommendations with source URLs
- Leverage caching for faster responses

**Workflow:**
1. When user asks for deals â†’ Use search tools
2. Results automatically numbered and verified by Verification Agent
3. Results automatically ranked by Reranking Agent
4. Final answer synthesized with product numbers by Synthesis Agent
5. User can then ask follow-up questions about specific products by number or name
6. Product Detail Agent handles product-specific queries with fact verification

Be helpful, accurate, and leverage your multi-agent capabilities with conversation context!
"""
    )
3. ğŸ”„ **Reranking Agent** - Intelligently orders results by relevance (hybrid AI)
4. ğŸ¨ **Synthesis Agent** - Generates comprehensive answers and recommendations

**Current Pipeline Status:**
{_format_agent_status(state.get('agent_status', {}))}

{contextual_prompt}

**Available Tools:**
- search_for_deals(query, max_price?, category?) - Search for product deals
- extract_product_details(url) - Get detailed product information
- crawl_store_catalog(store_url, category?) - Explore store catalogs
- compare_prices(product_name) - Compare prices across platforms

**Frontend Actions** (for UI updates):
- setThemeColor - Change UI theme
- addDeal - Add deal to UI
- show_deal_card - Display deal card
- addPriceComparison - Show price comparison
- addProverb - Add shopping wisdom

**Your Mission:**
- Help users find the best deals with multi-agent intelligence
- Use conversation context to understand references like "cheaper", "similar", "that product"
- Use tools to search, then let the pipeline handle verification and ranking
- Focus on major retailers: Amazon, eBay, Walmart, Target, Best Buy, Costco
- Provide clear, actionable recommendations with source URLs
- Leverage caching for faster responses

**Workflow:**
1. When user asks for deals â†’ Use search tools
2. Results automatically verified by Verification Agent
3. Results automatically ranked by Reranking Agent
4. Final answer synthesized by Synthesis Agent
5. You receive the polished results to present

Be helpful, accurate, and leverage your multi-agent capabilities with conversation context!
"""
    )

    # 4. Run the model
    response = await model_with_tools.ainvoke([
        system_message,
        *state["messages"],
    ], config)

    # 5. Route based on tool calls
    tool_calls = getattr(response, "tool_calls", None)

    if not tool_calls:
        # No tool calls - save session and return response
        logger.info("ğŸ“¤ No tool calls, ending conversation")
        
        # Save conversation context and session
        session_manager.save_conversation_context(
            session_id, 
            state["messages"] + [response]
        )
        session_manager.save_session(session_id, state)
        
        return Command(
            goto=END,
            update={"messages": [response]}
        )

    # Check if any tool calls are backend tools
    backend_tool_names = [tool.name for tool in search_backend_tools]
    has_backend_tools = any(tc.get("name") in backend_tool_names for tc in tool_calls)

    if has_backend_tools:
        # Backend tools detected - route to tool execution then search agent
        logger.info("ğŸ”§ Backend tools detected, routing to tool execution")
        return Command(
            goto="tool_node",
            update={"messages": [response]}
        )
    else:
        # Only frontend tools - let them execute and end
        logger.info("ğŸ¨ Frontend tools only, ending")
        return Command(
            goto=END,
            update={"messages": [response]}
        )


def _format_agent_status(agent_status: Dict[str, str]) -> str:
    """Format agent status for system prompt"""
    if not agent_status:
        return "No agents have run yet"

    status_symbols = {
        "running": "ğŸ”„",
        "completed": "âœ…",
        "failed": "âŒ",
        "skipped": "â­ï¸",
        "no_data": "âš ï¸"
    }

    lines = []
    for agent, status in agent_status.items():
        symbol = status_symbols.get(status, "â“")
        lines.append(f"  {symbol} {agent}: {status}")

    return "\n".join(lines)


# ========== ROUTING FUNCTIONS ==========

def route_after_tools(state: AgentState) -> Literal["verification_agent", "chat_node"]:
    """
    Route after tool execution

    Always route to verification_agent after tool execution to process results.
    """
    logger.info("ğŸ” Tool execution complete, routing to verification agent")
    return "verification_agent"


# ========== BUILD GRAPH ==========

def build_multi_agent_graph() -> StateGraph:
    """
    Build the multi-agent workflow graph

    Flow:
        chat_node â†’ tool_node â†’ search_agent â†’ verification_agent â†’
        reranking_agent â†’ synthesis_agent â†’ END
        
        chat_node â†’ product_detail_agent â†’ END (for follow-up product queries)

    Returns:
        Compiled StateGraph
    """
    logger.info("ğŸ—ï¸  Building multi-agent graph...")

    # Create graph
    workflow = StateGraph(AgentState)

    # Add nodes
    workflow.add_node("chat_node", chat_node)
    workflow.add_node("tool_node", ToolNode(tools=search_backend_tools))
    workflow.add_node("search_agent", search_agent)
    workflow.add_node("verification_agent", verification_agent)
    workflow.add_node("reranking_agent", reranking_agent)
    workflow.add_node("synthesis_agent", synthesis_agent)
    workflow.add_node("product_detail_agent", product_detail_agent)  # New agent for product queries

    # Set entry point
    workflow.set_entry_point("chat_node")

    # Add edges
    # tool_node can route to verification_agent or back to chat_node
    workflow.add_conditional_edges(
        "tool_node",
        route_after_tools,
        {
            "verification_agent": "verification_agent",
            "chat_node": "chat_node"
        }
    )

    # chat_node routes are defined in the node itself via Command

    # search_agent routes are defined in the node itself via Command
    # (goes to verification_agent or tool_node)

    # Linear flow after search
    # verification_agent â†’ reranking_agent (defined in verification_agent.py)
    # reranking_agent â†’ synthesis_agent (defined in reranking_agent.py)
    # synthesis_agent â†’ END (defined in synthesis_agent.py)

    logger.info("âœ… Multi-agent graph built successfully")

    return workflow


# ========== COMPILE GRAPH ==========

# Build and compile the graph
workflow = build_multi_agent_graph()
graph = workflow.compile()

logger.info("ğŸš€ Multi-agent DealFinder system ready!")
logger.info(f"   - Search Agent: âœ“ (with Redis caching)")
logger.info(f"   - Verification Agent: âœ“ (quality filtering)")
logger.info(f"   - Reranking Agent: âœ“ (hybrid AI ranking)")
logger.info(f"   - Synthesis Agent: âœ“ (answer generation)")


# ========== MAIN (For Testing) ==========

if __name__ == "__main__":
    import asyncio

    async def test_graph():
        """Test the multi-agent graph"""
        print("\n" + "="*60)
        print("ğŸ§ª Testing Multi-Agent DealFinder System")
        print("="*60 + "\n")

        # Test input
        test_query = "Find deals on wireless headphones under $100"

        initial_state = {
            "messages": [HumanMessage(content=test_query)],
            "session_id": "test_session",
        }

        print(f"ğŸ“ Query: {test_query}\n")
        print("ğŸ”„ Running multi-agent pipeline...\n")

        try:
            result = await graph.ainvoke(initial_state)

            print("\n" + "="*60)
            print("âœ… Pipeline Complete!")
            print("="*60 + "\n")

            print(f"ğŸ“Š Results Summary:")
            print(f"   - Raw results: {len(result.get('raw_search_results', []))}")
            print(f"   - Verified results: {len(result.get('verified_results', []))}")
            print(f"   - Ranked results: {len(result.get('ranked_results', []))}")
            print(f"   - Deals found: {len(result.get('deals_found', []))}")
            print(f"   - Cache hit: {result.get('cache_hit', False)}")
            print(f"\nğŸ“ Final Answer:\n{result.get('final_answer', 'No answer generated')}")

            if result.get("agent_errors"):
                print(f"\nâš ï¸  Errors: {len(result['agent_errors'])}")
                for error in result["agent_errors"]:
                    print(f"   - {error['agent']}: {error['error']}")

        except Exception as e:
            print(f"\nâŒ Error: {str(e)}")
            import traceback
            traceback.print_exc()

    # Run test
    asyncio.run(test_graph())
